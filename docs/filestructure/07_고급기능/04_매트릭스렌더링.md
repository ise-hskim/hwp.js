# 매트릭스 렌더링 시스템

HWP 5.0의 고급 도형 변환 및 렌더링 시스템에 대한 상세 설명입니다.

## 개요

매트릭스 렌더링 시스템은 도형의 회전, 확대/축소, 이동, 기울임 등의 변환을 수학적으로 정확하게 처리하는 시스템입니다.

## 변환 매트릭스 구조

### 기본 2D 변환 매트릭스

```c
struct TransformMatrix {
    FIXED m11, m12, m13;    // [m11 m12 m13]
    FIXED m21, m22, m23;    // [m21 m22 m23]  = 변환 매트릭스
    FIXED m31, m32, m33;    // [m31 m32 m33]
};

// 기본 항등 매트릭스
TransformMatrix identityMatrix = {
    65536, 0, 0,      // [1.0 0.0 0.0]
    0, 65536, 0,      // [0.0 1.0 0.0]
    0, 0, 65536       // [0.0 0.0 1.0]
};
```

### 점 변환 계산

```c
struct Point2D {
    SHWPUNIT x;
    SHWPUNIT y;
};

Point2D transformPoint(Point2D point, TransformMatrix matrix) {
    Point2D result;
    
    // 고정밀 계산을 위한 64비트 연산
    INT64 x = (INT64)point.x;
    INT64 y = (INT64)point.y;
    
    // 매트릭스 곱셈: [x y 1] * matrix
    INT64 newX = (x * matrix.m11 + y * matrix.m21 + matrix.m31) >> 16;
    INT64 newY = (x * matrix.m12 + y * matrix.m22 + matrix.m32) >> 16;
    
    result.x = (SHWPUNIT)newX;
    result.y = (SHWPUNIT)newY;
    
    return result;
}
```

## 기본 변환 함수들

### 1. 이동 변환 (Translation)

```c
TransformMatrix createTranslationMatrix(SHWPUNIT dx, SHWPUNIT dy) {
    TransformMatrix matrix = identityMatrix;
    matrix.m31 = (FIXED)(dx << 16);  // dx를 FIXED로 변환
    matrix.m32 = (FIXED)(dy << 16);  // dy를 FIXED로 변환
    return matrix;
}
```

### 2. 확대/축소 변환 (Scaling)

```c
TransformMatrix createScaleMatrix(double scaleX, double scaleY) {
    TransformMatrix matrix = identityMatrix;
    matrix.m11 = doubleToFixed(scaleX);
    matrix.m22 = doubleToFixed(scaleY);
    return matrix;
}
```

### 3. 회전 변환 (Rotation)

```c
TransformMatrix createRotationMatrix(double angleRadians) {
    double cosAngle = cos(angleRadians);
    double sinAngle = sin(angleRadians);
    
    TransformMatrix matrix = identityMatrix;
    matrix.m11 = doubleToFixed(cosAngle);
    matrix.m12 = doubleToFixed(-sinAngle);
    matrix.m21 = doubleToFixed(sinAngle);
    matrix.m22 = doubleToFixed(cosAngle);
    
    return matrix;
}

// HWP의 각도 단위 변환 (1/10도 -> 라디안)
double hwpAngleToRadians(INT16 hwpAngle) {
    return (hwpAngle / 10.0) * (M_PI / 180.0);
}
```

### 4. 기울임 변환 (Skew)

```c
TransformMatrix createSkewMatrix(double skewX, double skewY) {
    TransformMatrix matrix = identityMatrix;
    matrix.m12 = doubleToFixed(tan(skewX));
    matrix.m21 = doubleToFixed(tan(skewY));
    return matrix;
}
```

## 매트릭스 연산

### 매트릭스 곱셈

```c
TransformMatrix multiplyMatrices(TransformMatrix a, TransformMatrix b) {
    TransformMatrix result;
    
    // 3x3 매트릭스 곱셈 (고정밀 계산)
    result.m11 = (FIXED)(((INT64)a.m11 * b.m11 + (INT64)a.m12 * b.m21 + (INT64)a.m13 * b.m31) >> 16);
    result.m12 = (FIXED)(((INT64)a.m11 * b.m12 + (INT64)a.m12 * b.m22 + (INT64)a.m13 * b.m32) >> 16);
    result.m13 = (FIXED)(((INT64)a.m11 * b.m13 + (INT64)a.m12 * b.m23 + (INT64)a.m13 * b.m33) >> 16);
    
    result.m21 = (FIXED)(((INT64)a.m21 * b.m11 + (INT64)a.m22 * b.m21 + (INT64)a.m23 * b.m31) >> 16);
    result.m22 = (FIXED)(((INT64)a.m21 * b.m12 + (INT64)a.m22 * b.m22 + (INT64)a.m23 * b.m32) >> 16);
    result.m23 = (FIXED)(((INT64)a.m21 * b.m13 + (INT64)a.m22 * b.m23 + (INT64)a.m23 * b.m33) >> 16);
    
    result.m31 = (FIXED)(((INT64)a.m31 * b.m11 + (INT64)a.m32 * b.m21 + (INT64)a.m33 * b.m31) >> 16);
    result.m32 = (FIXED)(((INT64)a.m31 * b.m12 + (INT64)a.m32 * b.m22 + (INT64)a.m33 * b.m32) >> 16);
    result.m33 = (FIXED)(((INT64)a.m31 * b.m13 + (INT64)a.m32 * b.m23 + (INT64)a.m33 * b.m33) >> 16);
    
    return result;
}
```

### 역변환 매트릭스

```c
TransformMatrix invertMatrix(TransformMatrix matrix) {
    TransformMatrix result;
    
    // 2x2 부분의 역행렬 계산 (FIXED 정밀도 유지)
    INT64 det = (INT64)matrix.m11 * matrix.m22 - (INT64)matrix.m12 * matrix.m21;
    
    if (det == 0) {
        // 특이 매트릭스 - 역변환 불가능
        return identityMatrix;
    }
    
    // det의 역수 계산 (고정밀)
    INT64 invDet = (1LL << 32) / det;
    
    result.m11 = (FIXED)((matrix.m22 * invDet) >> 16);
    result.m12 = (FIXED)((-matrix.m12 * invDet) >> 16);
    result.m21 = (FIXED)((-matrix.m21 * invDet) >> 16);
    result.m22 = (FIXED)((matrix.m11 * invDet) >> 16);
    
    // 이동 부분의 역변환
    result.m31 = -(result.m11 * matrix.m31 + result.m21 * matrix.m32) >> 16;
    result.m32 = -(result.m12 * matrix.m31 + result.m22 * matrix.m32) >> 16;
    
    result.m13 = result.m23 = 0;
    result.m33 = 65536;  // 1.0
    
    return result;
}
```

## 렌더링 파이프라인

### 다단계 렌더링 시스템

```c
struct RenderingPipeline {
    TransformMatrix worldMatrix;        // 월드 좌표계 변환
    TransformMatrix viewMatrix;         // 뷰 변환 (페이지 좌표계)
    TransformMatrix projectionMatrix;   // 투영 변환 (화면 좌표계)
    
    // 렌더링 상태
    ClippingRect clipRect;              // 클리핑 영역
    RenderingQuality quality;           // 렌더링 품질
    BOOL antiAliasing;                  // 안티에일리어싱
};

void renderShape(Shape* shape, RenderingPipeline* pipeline) {
    // 1. 로컬 변환 적용
    TransformMatrix localMatrix = shape->localTransform;
    
    // 2. 부모 변환 적용
    TransformMatrix parentMatrix = getParentTransform(shape->parent);
    
    // 3. 매트릭스 결합
    TransformMatrix combinedMatrix = multiplyMatrices(localMatrix, parentMatrix);
    combinedMatrix = multiplyMatrices(combinedMatrix, pipeline->worldMatrix);
    combinedMatrix = multiplyMatrices(combinedMatrix, pipeline->viewMatrix);
    
    // 4. 도형별 렌더링
    switch (shape->type) {
        case SHAPE_RECTANGLE:
            renderRectangle(shape, combinedMatrix, pipeline);
            break;
        case SHAPE_ELLIPSE:
            renderEllipse(shape, combinedMatrix, pipeline);
            break;
        case SHAPE_POLYGON:
            renderPolygon(shape, combinedMatrix, pipeline);
            break;
        // 추가 도형 타입들...
    }
}
```

### 베지어 곡선 처리

```c
struct BezierCurve {
    Point2D controlPoints[4];    // 베지어 제어점
    BYTE precision;              // 정밀도 (세분화 수준)
};

void renderBezierCurve(BezierCurve* curve, TransformMatrix matrix, RenderingPipeline* pipeline) {
    // 제어점들을 변환
    Point2D transformedPoints[4];
    for (int i = 0; i < 4; i++) {
        transformedPoints[i] = transformPoint(curve->controlPoints[i], matrix);
    }
    
    // 베지어 곡선을 직선 세그먼트로 근사
    int segments = 1 << curve->precision;  // 2^precision 개의 세그먼트
    
    Point2D prevPoint = transformedPoints[0];
    for (int i = 1; i <= segments; i++) {
        double t = (double)i / segments;
        Point2D currentPoint = evaluateBezier(transformedPoints, t);
        
        drawLine(prevPoint, currentPoint, pipeline);
        prevPoint = currentPoint;
    }
}

Point2D evaluateBezier(Point2D points[4], double t) {
    // 드 카스텔조 알고리즘을 사용한 베지어 곡선 계산
    double u = 1.0 - t;
    double tt = t * t;
    double uu = u * u;
    double ttt = tt * t;
    double uuu = uu * u;
    
    Point2D result;
    result.x = (SHWPUNIT)(uuu * points[0].x + 3 * uu * t * points[1].x + 
                         3 * u * tt * points[2].x + ttt * points[3].x);
    result.y = (SHWPUNIT)(uuu * points[0].y + 3 * uu * t * points[1].y + 
                         3 * u * tt * points[2].y + ttt * points[3].y);
    
    return result;
}
```

## 고급 렌더링 기법

### 1. 그라디언트 렌더링 (5.0.2.0+)

```c
struct GradientInfo {
    BYTE type;                  // 선형/원형/각도별
    Point2D startPoint;         // 시작점
    Point2D endPoint;           // 끝점
    BYTE colorCount;            // 색상 개수
    ARGB_COLOR colors[8];       // 색상 배열
    BYTE positions[8];          // 색상 위치 (0-255)
    BYTE blendMode;             // 블렌딩 모드
};

void renderGradient(Rectangle rect, GradientInfo* gradient, 
                   TransformMatrix matrix, RenderingPipeline* pipeline) {
    // 그라디언트 영역을 변환
    Point2D corners[4] = {
        {rect.left, rect.top},
        {rect.right, rect.top},
        {rect.right, rect.bottom},
        {rect.left, rect.bottom}
    };
    
    for (int i = 0; i < 4; i++) {
        corners[i] = transformPoint(corners[i], matrix);
    }
    
    // 그라디언트 방향 계산
    Point2D gradientStart = transformPoint(gradient->startPoint, matrix);
    Point2D gradientEnd = transformPoint(gradient->endPoint, matrix);
    
    // 픽셀별 색상 보간
    for (int y = corners[0].y; y <= corners[2].y; y++) {
        for (int x = corners[0].x; x <= corners[2].x; x++) {
            double t = calculateGradientParameter(x, y, gradientStart, gradientEnd, gradient->type);
            ARGB_COLOR pixelColor = interpolateColor(gradient, t);
            setPixel(x, y, pixelColor);
        }
    }
}
```

### 2. 패턴 채우기 (5.0.3.0+)

```c
struct PatternInfo {
    WORD patternId;             // 패턴 ID (0-63)
    ARGB_COLOR foregroundColor; // 전경색
    ARGB_COLOR backgroundColor; // 배경색
    BYTE opacity;               // 투명도
    Point2D patternOffset;      // 패턴 오프셋
    double patternScale;        // 패턴 크기 배율
};

void renderPattern(Rectangle rect, PatternInfo* pattern, 
                  TransformMatrix matrix, RenderingPipeline* pipeline) {
    // 패턴 매트릭스 생성
    TransformMatrix patternMatrix = createScaleMatrix(pattern->patternScale, pattern->patternScale);
    patternMatrix = multiplyMatrices(patternMatrix, matrix);
    
    // 패턴 타일링
    for (int y = rect.top; y <= rect.bottom; y += PATTERN_TILE_SIZE) {
        for (int x = rect.left; x <= rect.right; x += PATTERN_TILE_SIZE) {
            Point2D tileOrigin = {x + pattern->patternOffset.x, y + pattern->patternOffset.y};
            tileOrigin = transformPoint(tileOrigin, patternMatrix);
            
            renderPatternTile(pattern->patternId, tileOrigin, pattern, pipeline);
        }
    }
}
```

## 최적화 기법

### 1. 매트릭스 스택 관리

```c
#define MAX_MATRIX_STACK_DEPTH 32

struct MatrixStack {
    TransformMatrix stack[MAX_MATRIX_STACK_DEPTH];
    int depth;
    TransformMatrix current;    // 현재 누적 매트릭스
};

void pushMatrix(MatrixStack* stack, TransformMatrix matrix) {
    if (stack->depth < MAX_MATRIX_STACK_DEPTH - 1) {
        stack->stack[stack->depth] = stack->current;
        stack->depth++;
        stack->current = multiplyMatrices(stack->current, matrix);
    }
}

void popMatrix(MatrixStack* stack) {
    if (stack->depth > 0) {
        stack->depth--;
        stack->current = stack->stack[stack->depth];
    }
}
```

### 2. 바운딩 박스 계산

```c
struct BoundingBox {
    SHWPUNIT left, top, right, bottom;
};

BoundingBox calculateTransformedBounds(BoundingBox originalBounds, TransformMatrix matrix) {
    // 네 꼭지점 변환
    Point2D corners[4] = {
        {originalBounds.left, originalBounds.top},
        {originalBounds.right, originalBounds.top},
        {originalBounds.right, originalBounds.bottom},
        {originalBounds.left, originalBounds.bottom}
    };
    
    BoundingBox result = {INT_MAX, INT_MAX, INT_MIN, INT_MIN};
    
    for (int i = 0; i < 4; i++) {
        Point2D transformed = transformPoint(corners[i], matrix);
        
        if (transformed.x < result.left) result.left = transformed.x;
        if (transformed.x > result.right) result.right = transformed.x;
        if (transformed.y < result.top) result.top = transformed.y;
        if (transformed.y > result.bottom) result.bottom = transformed.y;
    }
    
    return result;
}
```

### 3. 클리핑 최적화

```c
BOOL isCompletelyClipped(BoundingBox bounds, ClippingRect clipRect) {
    return (bounds.right < clipRect.left || bounds.left > clipRect.right ||
            bounds.bottom < clipRect.top || bounds.top > clipRect.bottom);
}

BOOL needsClipping(BoundingBox bounds, ClippingRect clipRect) {
    return !(bounds.left >= clipRect.left && bounds.right <= clipRect.right &&
             bounds.top >= clipRect.top && bounds.bottom <= clipRect.bottom);
}
```

## 복합 도형 처리

### 묶음 개체 (Container) 렌더링

```c
void renderContainer(Container* container, TransformMatrix parentMatrix, RenderingPipeline* pipeline) {
    // 컨테이너 자체 변환 적용
    TransformMatrix containerMatrix = multiplyMatrices(container->localTransform, parentMatrix);
    
    // 클리핑 영역 설정
    ClippingRect originalClip = pipeline->clipRect;
    if (container->hasClipping) {
        ClippingRect containerClip = transformClipRect(container->clipRect, containerMatrix);
        pipeline->clipRect = intersectClipRects(originalClip, containerClip);
    }
    
    // 자식 도형들 렌더링
    for (int i = 0; i < container->childCount; i++) {
        Shape* child = container->children[i];
        
        // 바운딩 박스 기반 culling
        BoundingBox childBounds = calculateTransformedBounds(child->bounds, containerMatrix);
        if (!isCompletelyClipped(childBounds, pipeline->clipRect)) {
            renderShape(child, containerMatrix, pipeline);
        }
    }
    
    // 클리핑 영역 복원
    pipeline->clipRect = originalClip;
}
```

## 텍스트 렌더링 매트릭스

### 문자 변환 처리

```c
struct TextRenderingInfo {
    TransformMatrix charMatrix;     // 문자별 변환
    SHWPUNIT baselineY;            // 베이스라인 Y 좌표
    SHWPUNIT charSpacing;          // 자간
    SHWPUNIT lineSpacing;          // 행간
    double rotationAngle;          // 텍스트 회전각
};

void renderTextRun(TextRun* textRun, TextRenderingInfo* renderInfo, 
                   TransformMatrix parentMatrix, RenderingPipeline* pipeline) {
    // 텍스트 전용 변환 매트릭스 생성
    TransformMatrix textMatrix = createTextMatrix(renderInfo);
    TransformMatrix finalMatrix = multiplyMatrices(textMatrix, parentMatrix);
    
    SHWPUNIT currentX = 0;
    
    for (int i = 0; i < textRun->length; i++) {
        WCHAR ch = textRun->text[i];
        
        // 문자 위치 계산
        Point2D charPos = {currentX, renderInfo->baselineY};
        charPos = transformPoint(charPos, finalMatrix);
        
        // 문자 렌더링
        renderCharacter(ch, charPos, textRun->charShape, pipeline);
        
        // 다음 문자 위치로 이동
        currentX += getCharacterWidth(ch, textRun->charShape) + renderInfo->charSpacing;
    }
}

TransformMatrix createTextMatrix(TextRenderingInfo* renderInfo) {
    TransformMatrix matrix = identityMatrix;
    
    if (renderInfo->rotationAngle != 0.0) {
        matrix = createRotationMatrix(renderInfo->rotationAngle);
    }
    
    return matrix;
}
```

## 성능 최적화

### 1. 매트릭스 캐싱

```c
struct MatrixCache {
    DWORD shapeId;              // 도형 ID
    TransformMatrix matrix;     // 계산된 매트릭스
    DWORD lastModified;         // 마지막 수정 시간
    BOOL isDirty;              // 다시 계산 필요 여부
};

TransformMatrix getCachedMatrix(DWORD shapeId, MatrixCache* cache, int cacheSize) {
    for (int i = 0; i < cacheSize; i++) {
        if (cache[i].shapeId == shapeId && !cache[i].isDirty) {
            return cache[i].matrix;
        }
    }
    
    // 캐시 미스 - 새로 계산
    return calculateShapeMatrix(shapeId);
}
```

### 2. 변환 최적화

```c
// 항등 매트릭스 검사
BOOL isIdentityMatrix(TransformMatrix matrix) {
    return (matrix.m11 == 65536 && matrix.m22 == 65536 && matrix.m33 == 65536 &&
            matrix.m12 == 0 && matrix.m13 == 0 && matrix.m21 == 0 && 
            matrix.m23 == 0 && matrix.m31 == 0 && matrix.m32 == 0);
}

// 단순 변환 감지
BOOL isSimpleTranslation(TransformMatrix matrix) {
    return (matrix.m11 == 65536 && matrix.m22 == 65536 &&
            matrix.m12 == 0 && matrix.m21 == 0);
}

// 최적화된 점 변환
Point2D fastTransformPoint(Point2D point, TransformMatrix matrix) {
    if (isIdentityMatrix(matrix)) {
        return point;  // 변환 없음
    }
    
    if (isSimpleTranslation(matrix)) {
        // 단순 이동만 처리
        Point2D result;
        result.x = point.x + (matrix.m31 >> 16);
        result.y = point.y + (matrix.m32 >> 16);
        return result;
    }
    
    // 일반적인 변환
    return transformPoint(point, matrix);
}
```

## 주의사항

1. **정밀도**: 고정밀 연산 사용으로 부동소수점 오차 방지
2. **오버플로**: 64비트 중간 계산으로 오버플로 방지
3. **특이점**: 역변환 불가능한 매트릭스 처리
4. **성능**: 캐싱과 최적화를 통한 렌더링 속도 향상
5. **메모리**: 매트릭스 스택 깊이 제한으로 스택 오버플로 방지