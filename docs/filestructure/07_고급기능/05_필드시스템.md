# 필드 시스템

HWP 5.0의 동적 콘텐츠 처리를 위한 필드 시스템에 대한 상세 설명입니다.

## 개요

필드 시스템은 문서 내에서 동적으로 변경되는 내용을 처리하는 시스템입니다. 날짜, 페이지 번호, 계산식, 상호 참조 등을 자동으로 업데이트합니다.

## 필드 구조

### 기본 필드 레코드 구조

```c
struct FieldHeader {
    DWORD ctrlId;               // 필드 타입 식별자
    WORD commandLength;         // 필드 명령 길이
    WCHAR command[commandLength]; // 필드 명령 문자열
    WORD optionLength;          // 옵션 길이
    BYTE options[optionLength]; // 필드 옵션
    WORD resultLength;          // 결과 길이
    WCHAR result[resultLength]; // 캐시된 결과
};
```

### 필드 명령 시스템

필드 명령은 특수 문자로 구분된 텍스트 명령입니다:

```
^d{ YYYY-MM-DD }    // 날짜 필드
^n{ 페이지 번호 }     // 페이지 번호 필드
^c{ SUM(A1:A10) }   // 계산식 필드
^r{ 참조이름 }       // 상호 참조 필드
```

## 필드 타입별 상세 구조

### 1. 날짜/시간 필드 (0x61, 0x62)

```c
struct DateTimeField {
    FieldHeader header;
    
    // 날짜 옵션
    BYTE dateFormat;            // 날짜 형식 (0-15)
    BYTE timeFormat;            // 시간 형식 (0-7)
    BYTE locale;                // 로케일 (0=한국어, 1=영어)
    BYTE autoUpdate;            // 자동 업데이트 여부
    
    // 고정 날짜 (autoUpdate=0인 경우)
    WORD year;                  // 연도
    BYTE month;                 // 월 (1-12)
    BYTE day;                   // 일 (1-31)
    BYTE hour;                  // 시 (0-23)
    BYTE minute;                // 분 (0-59)
    BYTE second;                // 초 (0-59)
};

// 날짜 형식 정의
enum DateFormat {
    DATE_YYYY_MM_DD = 0,        // 2023-12-25
    DATE_YYYY_M_D = 1,          // 2023-12-25
    DATE_YY_MM_DD = 2,          // 23-12-25
    DATE_MM_DD_YYYY = 3,        // 12-25-2023
    DATE_DD_MM_YYYY = 4,        // 25-12-2023
    DATE_KOREAN_FULL = 5,       // 2023년 12월 25일
    DATE_KOREAN_SHORT = 6,      // 23년 12월 25일
    // 추가 형식들...
};
```

### 2. 계산식 필드 (0x67)

```c
struct FormulaField {
    FieldHeader header;
    
    // 수식 정보
    WORD formulaLength;         // 수식 길이
    WCHAR formula[formulaLength]; // 수식 문자열
    
    // 참조 정보
    WORD refCount;              // 참조 셀 개수
    struct CellReference {
        DWORD tableId;          // 테이블 ID
        WORD row;               // 행 번호
        WORD col;               // 열 번호
        BYTE refType;           // 참조 타입 (절대/상대)
    } references[refCount];
    
    // 결과 캐시
    BYTE resultType;            // 결과 타입 (숫자/문자열/오류)
    union {
        double numberResult;    // 숫자 결과
        struct {
            WORD length;
            WCHAR text[length];
        } stringResult;         // 문자열 결과
        DWORD errorCode;        // 오류 코드
    } cachedResult;
    
    // 의존성 정보
    DWORD lastCalculated;       // 마지막 계산 시간
    DWORD dependencyChecksum;   // 의존성 체크섬
};
```

### 3. 하이퍼링크 필드 (0x6B)

```c
struct HyperlinkField {
    FieldHeader header;
    
    // 링크 정보
    WORD urlLength;             // URL 길이
    WCHAR url[urlLength];       // 대상 URL
    WORD tooltipLength;         // 툴팁 길이
    WCHAR tooltip[tooltipLength]; // 툴팁 텍스트
    
    // 표시 옵션
    BYTE linkType;              // 링크 타입
    COLORREF linkColor;         // 링크 색상
    COLORREF visitedColor;      // 방문한 링크 색상
    BYTE underlineStyle;        // 밑줄 스타일
    
    // 동작 설정
    BYTE targetFrame;           // 대상 프레임
    BYTE confirmBeforeJump;     // 이동 전 확인
};

enum LinkType {
    LINK_URL = 0,               // 웹 URL
    LINK_FILE = 1,              // 로컬 파일
    LINK_BOOKMARK = 2,          // 문서 내 책갈피
    LINK_EMAIL = 3,             // 이메일 주소
    LINK_FTP = 4                // FTP 주소
};
```

### 4. 상호 참조 필드 (0x66)

```c
struct CrossRefField {
    FieldHeader header;
    
    // 참조 대상
    WORD targetLength;          // 대상 이름 길이
    WCHAR target[targetLength]; // 대상 이름 (책갈피, 표 제목 등)
    
    // 참조 형식
    BYTE refFormat;             // 참조 형식
    BYTE includeContext;        // 컨텍스트 포함 여부
    
    // 하이퍼링크 옵션
    BYTE createHyperlink;       // 하이퍼링크 생성 여부
    COLORREF hyperlinkColor;    // 하이퍼링크 색상
};

enum CrossRefFormat {
    CROSSREF_PAGE_NUMBER = 0,   // 페이지 번호만
    CROSSREF_TEXT_ONLY = 1,     // 텍스트만
    CROSSREF_PAGE_AND_TEXT = 2, // 페이지 번호와 텍스트
    CROSSREF_ABOVE_BELOW = 3    // "위" 또는 "아래"
};
```

## 필드 명령 처리

### 명령 파서

```c
struct FieldCommand {
    char command[64];           // 명령 이름
    int paramCount;             // 매개변수 개수
    char params[16][256];       // 매개변수 배열
    int options;                // 옵션 플래그
};

FieldCommand parseFieldCommand(const WCHAR* commandText) {
    FieldCommand cmd = {0};
    
    // 명령 구문 분석: ^command{ param1, param2, ... }
    const WCHAR* start = wcschr(commandText, L'^');
    if (!start) return cmd;
    
    const WCHAR* nameEnd = wcschr(start, L'{');
    if (!nameEnd) return cmd;
    
    // 명령 이름 추출
    int nameLen = nameEnd - start - 1;
    wcsncpy(cmd.command, start + 1, nameLen);
    cmd.command[nameLen] = 0;
    
    // 매개변수 추출
    const WCHAR* paramStart = nameEnd + 1;
    const WCHAR* paramEnd = wcschr(paramStart, L'}');
    
    if (paramEnd) {
        parseParameters(paramStart, paramEnd - paramStart, &cmd);
    }
    
    return cmd;
}

void parseParameters(const WCHAR* paramText, int length, FieldCommand* cmd) {
    // CSV 스타일 매개변수 파싱
    const WCHAR* current = paramText;
    const WCHAR* end = paramText + length;
    
    while (current < end && cmd->paramCount < 16) {
        const WCHAR* comma = wcschr(current, L',');
        if (!comma) comma = end;
        
        int paramLen = comma - current;
        wcsncpy(cmd->params[cmd->paramCount], current, paramLen);
        cmd->params[cmd->paramCount][paramLen] = 0;
        
        // 공백 제거
        trimWhitespace(cmd->params[cmd->paramCount]);
        
        cmd->paramCount++;
        current = comma + 1;
    }
}
```

### 특수 명령 마커 처리

```c
struct SpecialMarker {
    WCHAR marker[4];            // 마커 문자열
    BYTE markerType;            // 마커 타입
    DWORD targetId;             // 대상 ID
};

// 특수 마커 정의
enum SpecialMarkerType {
    MARKER_NEWLINE = 0,         // ^n (줄바꿈)
    MARKER_PAGEBREAK = 1,       // ^N (페이지 나눔)
    MARKER_TAB = 2,             // ^t (탭)
    MARKER_SPACE = 3,           // ^s (공백)
    MARKER_DATE_INSERT = 4,     // ^d (날짜 삽입)
    MARKER_CALC_RESULT = 5,     // ^c (계산 결과)
    MARKER_BOOKMARK = 6,        // ^b (책갈피)
    MARKER_HYPERLINK = 7,       // ^h (하이퍼링크)
    MARKER_FOOTNOTE = 8,        // ^f (각주)
    MARKER_ENDNOTE = 9,         // ^e (미주)
    MARKER_COMMENT = 10         // ^m (메모)
};

void processSpecialMarker(SpecialMarker* marker, RenderingContext* context) {
    switch (marker->markerType) {
        case MARKER_NEWLINE:
            context->currentX = context->leftMargin;
            context->currentY += context->lineHeight;
            break;
            
        case MARKER_PAGEBREAK:
            context->currentPage++;
            context->currentX = context->leftMargin;
            context->currentY = context->topMargin;
            break;
            
        case MARKER_TAB:
            moveToNextTabStop(context);
            break;
            
        case MARKER_DATE_INSERT:
            insertCurrentDate(context, marker->targetId);
            break;
            
        case MARKER_CALC_RESULT:
            insertCalculationResult(context, marker->targetId);
            break;
            
        // 추가 마커 처리...
    }
}
```

## 필드 업데이트 시스템

### 의존성 그래프

```c
struct FieldDependency {
    DWORD fieldId;              // 필드 ID
    DWORD dependsOnCount;       // 의존 필드 수
    DWORD dependsOn[32];        // 의존 필드 ID들
    DWORD lastUpdate;           // 마지막 업데이트 시간
    BOOL needsUpdate;           // 업데이트 필요 여부
};

void updateFieldsDependency(FieldDependency* dependencies, int fieldCount) {
    // 위상 정렬을 사용한 의존성 해결
    BOOL visited[fieldCount];
    BOOL updating[fieldCount];
    
    memset(visited, 0, sizeof(visited));
    memset(updating, 0, sizeof(updating));
    
    for (int i = 0; i < fieldCount; i++) {
        if (!visited[i]) {
            updateFieldRecursive(i, dependencies, fieldCount, visited, updating);
        }
    }
}

void updateFieldRecursive(int fieldIndex, FieldDependency* dependencies, int fieldCount,
                         BOOL* visited, BOOL* updating) {
    if (updating[fieldIndex]) {
        // 순환 의존성 감지
        reportCircularDependency(fieldIndex);
        return;
    }
    
    if (visited[fieldIndex]) {
        return;  // 이미 업데이트됨
    }
    
    updating[fieldIndex] = TRUE;
    
    // 의존 필드들을 먼저 업데이트
    FieldDependency* field = &dependencies[fieldIndex];
    for (int i = 0; i < field->dependsOnCount; i++) {
        int depIndex = findFieldIndex(field->dependsOn[i], dependencies, fieldCount);
        if (depIndex >= 0) {
            updateFieldRecursive(depIndex, dependencies, fieldCount, visited, updating);
        }
    }
    
    // 현재 필드 업데이트
    updateSingleField(fieldIndex);
    
    visited[fieldIndex] = TRUE;
    updating[fieldIndex] = FALSE;
}
```

### 계산식 필드 처리

```c
struct CalculationEngine {
    // 연산자 우선순위 테이블
    struct Operator {
        char symbol[4];
        int precedence;
        BOOL isLeftAssociative;
        CalculationResult (*calculate)(double a, double b);
    } operators[32];
    
    // 함수 테이블
    struct Function {
        char name[32];
        int paramCount;
        CalculationResult (*evaluate)(double* params, int count);
    } functions[64];
    
    // 변수 테이블
    struct Variable {
        char name[32];
        double value;
        DWORD lastUpdate;
    } variables[256];
};

CalculationResult evaluateFormula(const WCHAR* formula, CalculationEngine* engine) {
    // 수식을 토큰으로 분해
    Token tokens[256];
    int tokenCount = tokenizeFormula(formula, tokens, 256);
    
    // 중위 표기법을 후위 표기법으로 변환 (Shunting-yard 알고리즘)
    Token postfix[256];
    int postfixCount = infixToPostfix(tokens, tokenCount, postfix, 256);
    
    // 후위 표기법 계산
    double stack[64];
    int stackTop = 0;
    
    for (int i = 0; i < postfixCount; i++) {
        Token* token = &postfix[i];
        
        switch (token->type) {
            case TOKEN_NUMBER:
                stack[stackTop++] = token->numberValue;
                break;
                
            case TOKEN_VARIABLE:
                double varValue = getVariableValue(token->textValue, engine);
                stack[stackTop++] = varValue;
                break;
                
            case TOKEN_OPERATOR:
                if (stackTop >= 2) {
                    double b = stack[--stackTop];
                    double a = stack[--stackTop];
                    Operator* op = findOperator(token->textValue, engine);
                    CalculationResult result = op->calculate(a, b);
                    stack[stackTop++] = result.value;
                }
                break;
                
            case TOKEN_FUNCTION:
                Function* func = findFunction(token->textValue, engine);
                if (stackTop >= func->paramCount) {
                    double params[16];
                    for (int j = 0; j < func->paramCount; j++) {
                        params[j] = stack[stackTop - func->paramCount + j];
                    }
                    stackTop -= func->paramCount;
                    
                    CalculationResult result = func->evaluate(params, func->paramCount);
                    stack[stackTop++] = result.value;
                }
                break;
        }
    }
    
    CalculationResult final = {0};
    if (stackTop == 1) {
        final.value = stack[0];
        final.isValid = TRUE;
    } else {
        final.isValid = FALSE;
        final.errorCode = CALC_ERROR_INVALID_EXPRESSION;
    }
    
    return final;
}
```

### 3. 상호 참조 필드 처리

```c
struct BookmarkRegistry {
    struct Bookmark {
        WCHAR name[64];          // 책갈피 이름
        DWORD sectionId;         // 섹션 ID
        DWORD paragraphId;       // 문단 ID
        DWORD characterOffset;   // 문자 오프셋
        WORD pageNumber;         // 페이지 번호
        WCHAR context[256];      // 주변 컨텍스트
    } bookmarks[1024];
    
    int bookmarkCount;
};

CrossRefResult resolveCrossReference(const WCHAR* targetName, 
                                   BookmarkRegistry* registry,
                                   CrossRefFormat format) {
    CrossRefResult result = {0};
    
    // 책갈피 검색
    Bookmark* bookmark = findBookmark(targetName, registry);
    if (!bookmark) {
        result.isValid = FALSE;
        wcscpy(result.text, L"[참조 오류]");
        return result;
    }
    
    // 형식에 따른 결과 생성
    switch (format) {
        case CROSSREF_PAGE_NUMBER:
            swprintf(result.text, 64, L"%d", bookmark->pageNumber);
            break;
            
        case CROSSREF_TEXT_ONLY:
            wcsncpy(result.text, bookmark->context, 63);
            result.text[63] = 0;
            break;
            
        case CROSSREF_PAGE_AND_TEXT:
            swprintf(result.text, 64, L"%ls (%d쪽)", 
                    bookmark->context, bookmark->pageNumber);
            break;
            
        case CROSSREF_ABOVE_BELOW:
            int currentPage = getCurrentPageNumber();
            if (bookmark->pageNumber < currentPage) {
                wcscpy(result.text, L"위");
            } else if (bookmark->pageNumber > currentPage) {
                wcscpy(result.text, L"아래");
            } else {
                wcscpy(result.text, L"이 페이지");
            }
            break;
    }
    
    result.isValid = TRUE;
    result.targetPageNumber = bookmark->pageNumber;
    
    return result;
}
```

## 고급 필드 기능 (5.0.3.0+)

### 1. 조건부 필드

```c
struct ConditionalField {
    FieldHeader header;
    
    // 조건 정보
    WORD conditionLength;       // 조건 길이
    WCHAR condition[conditionLength]; // 조건 표현식
    
    // 분기 결과
    WORD trueResultLength;      // 참일 때 결과 길이
    WCHAR trueResult[trueResultLength];
    
    WORD falseResultLength;     // 거짓일 때 결과 길이
    WCHAR falseResult[falseResultLength];
    
    // 조건 타입
    BYTE conditionType;         // 비교/존재성/값 범위 등
};

BOOL evaluateCondition(const WCHAR* condition, FieldContext* context) {
    // 조건 표현식 파싱
    ConditionAST* ast = parseConditionExpression(condition);
    
    // AST 평가
    return evaluateConditionAST(ast, context);
}
```

### 2. 반복 필드 (메일 머지)

```c
struct MailMergeField {
    FieldHeader header;
    
    // 데이터 소스
    WORD dataSourceLength;      // 데이터 소스 길이
    WCHAR dataSource[dataSourceLength]; // 데이터 소스 경로
    
    // 필드 매핑
    WORD fieldMappingCount;     // 필드 매핑 수
    struct FieldMapping {
        WCHAR sourceField[64];  // 소스 필드명
        WCHAR targetField[64];  // 대상 필드명
        BYTE dataType;          // 데이터 타입
    } fieldMappings[fieldMappingCount];
    
    // 필터 조건
    WORD filterLength;          // 필터 조건 길이
    WCHAR filter[filterLength]; // 필터 조건
};
```

## 필드 캐시 시스템

### 캐시 관리

```c
struct FieldCache {
    DWORD fieldId;              // 필드 ID
    WCHAR cachedResult[1024];   // 캐시된 결과
    DWORD cacheTime;            // 캐시 생성 시간
    DWORD dependencyHash;       // 의존성 해시
    BOOL isValid;               // 캐시 유효성
};

void invalidateFieldCache(DWORD fieldId, FieldCache* cache, int cacheSize) {
    // 직접 무효화
    for (int i = 0; i < cacheSize; i++) {
        if (cache[i].fieldId == fieldId) {
            cache[i].isValid = FALSE;
        }
    }
    
    // 의존성 기반 연쇄 무효화
    for (int i = 0; i < cacheSize; i++) {
        if (cache[i].isValid && dependsOnField(cache[i].fieldId, fieldId)) {
            invalidateFieldCache(cache[i].fieldId, cache, cacheSize);
        }
    }
}
```

### 자동 업데이트 스케줄러

```c
struct FieldUpdateScheduler {
    struct UpdateTask {
        DWORD fieldId;
        DWORD scheduleTime;     // 업데이트 예정 시간
        WORD updateInterval;    // 업데이트 간격 (초)
        BYTE priority;          // 우선순위
    } tasks[256];
    
    int taskCount;
    DWORD lastUpdateTime;
};

void scheduleFieldUpdate(FieldUpdateScheduler* scheduler, DWORD fieldId, 
                        WORD interval, BYTE priority) {
    if (scheduler->taskCount < 256) {
        UpdateTask* task = &scheduler->tasks[scheduler->taskCount++];
        task->fieldId = fieldId;
        task->updateInterval = interval;
        task->priority = priority;
        task->scheduleTime = getCurrentTime() + interval;
    }
}

void processScheduledUpdates(FieldUpdateScheduler* scheduler) {
    DWORD currentTime = getCurrentTime();
    
    // 우선순위 정렬
    qsort(scheduler->tasks, scheduler->taskCount, sizeof(UpdateTask), compareTaskPriority);
    
    for (int i = 0; i < scheduler->taskCount; i++) {
        UpdateTask* task = &scheduler->tasks[i];
        
        if (task->scheduleTime <= currentTime) {
            // 필드 업데이트 실행
            updateFieldValue(task->fieldId);
            
            // 다음 업데이트 스케줄
            task->scheduleTime = currentTime + task->updateInterval;
        }
    }
}
```

## 오류 처리 및 복구

### 필드 오류 타입

```c
enum FieldError {
    FIELD_ERROR_NONE = 0,
    FIELD_ERROR_SYNTAX = 1,             // 구문 오류
    FIELD_ERROR_CIRCULAR_DEPENDENCY = 2, // 순환 의존성
    FIELD_ERROR_MISSING_TARGET = 3,     // 대상 없음
    FIELD_ERROR_INVALID_DATA_TYPE = 4,  // 잘못된 데이터 타입
    FIELD_ERROR_CALCULATION_OVERFLOW = 5, // 계산 오버플로
    FIELD_ERROR_DIVISION_BY_ZERO = 6,   // 0으로 나누기
    FIELD_ERROR_NETWORK_TIMEOUT = 7,    // 네트워크 타임아웃
    FIELD_ERROR_PERMISSION_DENIED = 8   // 권한 거부
};

void handleFieldError(DWORD fieldId, FieldError errorType) {
    switch (errorType) {
        case FIELD_ERROR_SYNTAX:
            setFieldResult(fieldId, L"[구문 오류]");
            break;
            
        case FIELD_ERROR_CIRCULAR_DEPENDENCY:
            setFieldResult(fieldId, L"[순환 참조]");
            break;
            
        case FIELD_ERROR_MISSING_TARGET:
            setFieldResult(fieldId, L"[참조 오류]");
            break;
            
        case FIELD_ERROR_CALCULATION_OVERFLOW:
            setFieldResult(fieldId, L"[계산 오류]");
            break;
            
        default:
            setFieldResult(fieldId, L"[필드 오류]");
            break;
    }
    
    // 오류 로그 기록
    logFieldError(fieldId, errorType, getCurrentTime());
}
```

## 성능 최적화

### 1. 지연 계산 (Lazy Evaluation)

```c
struct LazyField {
    DWORD fieldId;
    BOOL isCalculated;
    WCHAR* cachedResult;
    DWORD cacheSize;
    
    // 계산 함수 포인터
    FieldResult (*calculateFunction)(DWORD fieldId, void* context);
    void* calculationContext;
};

WCHAR* getFieldResult(DWORD fieldId, LazyField* lazyFields, int count) {
    LazyField* field = findLazyField(fieldId, lazyFields, count);
    
    if (!field) {
        return NULL;
    }
    
    if (!field->isCalculated) {
        // 지연 계산 실행
        FieldResult result = field->calculateFunction(fieldId, field->calculationContext);
        
        // 결과 캐시
        if (result.isValid) {
            field->cachedResult = wcsdup(result.text);
            field->isCalculated = TRUE;
        }
    }
    
    return field->cachedResult;
}
```

### 2. 배치 업데이트

```c
void batchUpdateFields(DWORD* fieldIds, int count) {
    // 의존성 그래프 구축
    DependencyGraph graph;
    buildDependencyGraph(&graph, fieldIds, count);
    
    // 위상 정렬로 업데이트 순서 결정
    DWORD updateOrder[count];
    topologicalSort(&graph, updateOrder, count);
    
    // 배치로 업데이트 실행
    for (int i = 0; i < count; i++) {
        updateFieldValue(updateOrder[i]);
    }
    
    // 결과 커밋
    commitFieldUpdates();
}
```

## 국제화 지원

### 다국어 필드 처리

```c
struct LocalizedField {
    FieldHeader header;
    
    BYTE supportedLanguages;    // 지원 언어 마스크
    struct LanguageVariant {
        BYTE languageCode;      // 언어 코드
        WORD commandLength;     // 명령 길이
        WCHAR command[commandLength]; // 언어별 명령
        WORD resultLength;      // 결과 길이
        WCHAR result[resultLength];   // 언어별 결과
    } variants[7];              // 최대 7개 언어
};

WCHAR* getLocalizedFieldResult(LocalizedField* field, BYTE currentLanguage) {
    // 현재 언어에 맞는 결과 반환
    for (int i = 0; i < 7; i++) {
        if (field->variants[i].languageCode == currentLanguage) {
            return field->variants[i].result;
        }
    }
    
    // 기본 언어 (한국어) 반환
    return field->variants[0].result;
}
```

## 주의사항

1. **순환 의존성**: 필드 간 순환 참조 방지
2. **성능**: 대량 필드 업데이트 시 배치 처리 사용
3. **메모리**: 캐시된 결과의 메모리 사용량 모니터링
4. **정확성**: 부동소수점 계산 시 정밀도 고려
5. **보안**: 외부 데이터 소스 접근 시 보안 검증
6. **호환성**: 이전 버전에서 지원하지 않는 필드 처리
7. **현지화**: 날짜/숫자 형식의 로케일별 처리