# 레코드 구조

## 기본 레코드 구조

모든 레코드는 다음과 같은 기본 구조를 가집니다:

```
struct Record {
    DWORD tagId;        // 레코드 태그 (4바이트)
    BYTE data[size];    // 레코드 데이터 (가변 길이)
}
```

## 태그 구조

32비트 태그는 세 부분으로 구성됩니다:

```
비트 31-22: 태그 ID (10비트) - 레코드 종류 (0~1023)
비트 21-12: 레벨 (10비트) - 계층 구조에서의 깊이 (0~1023)
비트 11-0:  크기 (12비트) - 데이터 크기 (최대 4095)
```

### 태그 헤더 확장 규칙

- **표준 헤더**: 4바이트 (32비트)
- **확장 헤더**: 크기가 4095(0xFFF)인 경우 추가 4바이트로 실제 크기 저장
- **버전별 확장**: 5.0.1.0부터 인스턴스 ID 지원
- **필드 확장**: 5.0.3.2부터 변경 추적 병합 정보 추가

### 태그 분해 예제

```c
#define HWPTAG_BEGIN 0x10
#define HWPTAG_EXTENDED_SIZE 0xFFF
#define MAX_RECORD_SIZE 0xFFFFFFFF

typedef struct {
    UINT16 tagId;           // 태그 ID (0-1023)
    UINT16 level;           // 레벨 (0-1023)
    UINT32 size;            // 크기
    BOOL isExtended;        // 확장 크기 여부
    BOOL isCompressed;      // 압축 여부 (5.0.1.0+)
    UINT32 originalSize;    // 원본 크기 (압축 시)
} TagInfo;

void parseTag(DWORD tag, TagInfo* info) {
    info->tagId = (tag >> 22) & 0x3FF;      // 상위 10비트
    info->level = (tag >> 12) & 0x3FF;      // 중간 10비트
    info->size = tag & 0xFFF;               // 하위 12비트
    info->isExtended = (info->size == HWPTAG_EXTENDED_SIZE);
    info->isCompressed = isCompressedRecord(info->tagId);
    info->originalSize = info->size;
}

// 압축 레코드 판별 (5.0.1.0+)
BOOL isCompressedRecord(UINT16 tagId) {
    static UINT16 compressibleTags[] = {
        HWPTAG_PARA_TEXT,
        HWPTAG_SHAPE_COMPONENT_PICTURE,
        HWPTAG_CHART_DATA,
        HWPTAG_VIDEO_DATA,
        HWPTAG_CTRL_DATA
    };
    
    for (int i = 0; i < sizeof(compressibleTags)/sizeof(UINT16); i++) {
        if (tagId == compressibleTags[i]) {
            return TRUE;
        }
    }
    return FALSE;
}
```

## 확장 크기

크기가 4095(0xFFF)인 경우, 실제 크기는 별도로 저장됩니다:

```
struct ExtendedRecord {
    DWORD tagId;         // 태그 (크기 부분이 0xFFF)
    DWORD extendedSize;  // 실제 크기 (최대 2^32-1)
    BYTE data[extendedSize];
}
```

### 확장 헤더 처리 알고리즘

```c
DWORD readRecordSize(DWORD tag) {
    DWORD basicSize = tag & 0xFFF;
    if (basicSize == 0xFFF) {
        // 확장 크기 읽기
        DWORD extendedSize = readDWORD();
        return extendedSize;
    }
    return basicSize;
}
```

### 압축 플래그 처리

버전 5.0.1.0부터 레코드별 압축 플래그 지원:

```c
struct CompressedRecord {
    DWORD tagId;             // 태그 ID
    DWORD originalSize;      // 원본 크기
    DWORD compressedSize;    // 압축된 크기
    BYTE compressedData[compressedSize]; // zlib 압축 데이터
}
```

## 레코드 종류

### 문서 정보 레코드 (HWPTAG_BEGIN=0x10 기준)
| Tag ID | Value | 이름 | 설명 | 버전 |
|--------|-------|------|------|------|
| HWPTAG_DOCUMENT_PROPERTIES | 0x10 | 문서 속성 | 전체 문서 속성 정보 | 5.0+ |
| HWPTAG_ID_MAPPINGS | 0x11 | ID 매핑 테이블 | 각종 ID 개수 정보 | 5.0+ |
| HWPTAG_BIN_DATA | 0x12 | 바이너리 데이터 링크 | 이미지/OLE 링크 정보 | 5.0+ |
| HWPTAG_FACE_NAME | 0x13 | 글꼴 이름 | 폰트 정보 | 5.0+ |
| HWPTAG_BORDER_FILL | 0x14 | 테두리/배경 | 테두리와 배경 스타일 | 5.0+ |
| HWPTAG_CHAR_SHAPE | 0x15 | 글자 모양 | 글자 서식 정보 | 5.0+ |
| HWPTAG_TAB_DEF | 0x16 | 탭 정의 | 탭 설정 정보 | 5.0+ |
| HWPTAG_NUMBERING | 0x17 | 번호 매기기 | 번호 매기기 스타일 | 5.0+ |
| HWPTAG_BULLET | 0x18 | 글머리표 | 불릿 스타일 | 5.0+ |
| HWPTAG_PARA_SHAPE | 0x19 | 문단 모양 | 문단 서식 정보 | 5.0+ |
| HWPTAG_STYLE | 0x1A | 스타일 | 문서 스타일 정의 | 5.0+ |
| HWPTAG_DOC_DATA | 0x1B | 문서 임의 데이터 | 사용자 정의 데이터 | 5.0+ |
| HWPTAG_DISTRIBUTE_DOC_DATA | 0x1C | 배포용 문서 데이터 | 배포 전용 데이터 | 5.0+ |
| HWPTAG_RESERVED | 0x1D | 예약 | 예약된 영역 | 5.0+ |
| HWPTAG_COMPATIBLE_DOCUMENT | 0x1E | 호환 문서 | 호환성 정보 | 5.0+ |
| HWPTAG_LAYOUT_COMPATIBILITY | 0x1F | 레이아웃 호환성 | 레이아웃 호환 설정 | 5.0+ |
| HWPTAG_TRACKCHANGE | 0x20 | 변경 추적 정보 | 변경 추적 설정 | 5.0+ |
| HWPTAG_MEMO_SHAPE | 0x5C | 메모 모양 | 메모 스타일 정보 | 5.0.1.0+ |
| HWPTAG_FORBIDDEN_CHAR | 0x5E | 금칙처리 문자 | 금칙 문자 처리 규칙 | 5.0.2.0+ |
| HWPTAG_TRACK_CHANGE | 0x60 | 변경 추적 내용 | 실제 변경 추적 데이터 | 5.0.1.0+ |
| HWPTAG_TRACK_CHANGE_AUTHOR | 0x61 | 변경 추적 작성자 | 변경 작성자 정보 | 5.0.1.0+ |

### 본문 레코드 (0x50 ~ 0x9F, HWPTAG_BEGIN+0x40 기준)
| Tag ID | Value | 이름 | 설명 | 버전 |
|--------|-------|------|------|------|
| HWPTAG_PAGE_DEF | 0x50 | 페이지 정의 | 페이지 설정 정보 | 5.0+ |
| HWPTAG_FOOTNOTE_SHAPE | 0x51 | 각주 모양 | 각주 스타일 | 5.0+ |
| HWPTAG_PARA_HEADER | 0x52 | 문단 헤더 | 문단 속성 정보 | 5.0+ |
| HWPTAG_PARA_TEXT | 0x53 | 문단 텍스트 | 실제 텍스트 내용 | 5.0+ |
| HWPTAG_PARA_CHAR_SHAPE | 0x54 | 문단 글자 모양 | 글자별 서식 변경점 | 5.0+ |
| HWPTAG_PARA_LINE_SEG | 0x55 | 문단 줄 나눔 | 줄별 레이아웃 정보 | 5.0+ |
| HWPTAG_PARA_RANGE_TAG | 0x56 | 문단 영역 태그 | 텍스트 범위 마킹 | 5.0+ |
| HWPTAG_CTRL_HEADER | 0x57 | 컨트롤 헤더 | 컨트롤 객체 헤더 | 5.0+ |
| HWPTAG_LIST_HEADER | 0x58 | 문단 리스트 헤더 | 중첩 문단 구조 | 5.0+ |
| HWPTAG_PAGE_BORDER_FILL | 0x59 | 페이지 테두리/배경 | 페이지 스타일 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT | 0x5A | 개체 요소 | 도형 공통 속성 | 5.0+ |
| HWPTAG_TABLE | 0x5B | 표 | 테이블 구조 정보 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_LINE | 0x5C | 선 개체 | 직선/곡선 정보 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_RECTANGLE | 0x5D | 사각형 개체 | 사각형 속성 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_ELLIPSE | 0x5E | 타원 개체 | 타원/원 속성 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_ARC | 0x5F | 호 개체 | 호 모양 속성 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_POLYGON | 0x60 | 다각형 개체 | 다각형 꼭짓점 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_CURVE | 0x61 | 곡선 개체 | 베지어 곡선 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_OLE | 0x62 | OLE 개체 | 포함된 객체 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_PICTURE | 0x63 | 그림 개체 | 이미지 속성 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_CONTAINER | 0x64 | 묶음 개체 | 그룹 컨테이너 | 5.0+ |
| HWPTAG_CTRL_DATA | 0x65 | 컨트롤 임의 데이터 | 컨트롤별 추가 데이터 | 5.0+ |
| HWPTAG_EQEDIT | 0x66 | 수식 개체 | 수학 수식 | 5.0+ |
| HWPTAG_SHAPE_COMPONENT_TEXTART | 0x67 | 글맵시 | 텍스트 아트 | 5.0+ |
| HWPTAG_FORM_OBJECT | 0x68 | 양식 개체 | 입력 양식 | 5.0+ |
| HWPTAG_MEMO_SHAPE | 0x69 | 메모 모양 | 메모 스타일 | 5.0.1.0+ |
| HWPTAG_MEMO_LIST | 0x6A | 메모 리스트 | 메모 목록 | 5.0.1.0+ |
| HWPTAG_CHART_DATA | 0x6B | 차트 데이터 | 차트 정보 | 5.0.2.0+ |
| HWPTAG_VIDEO_DATA | 0x6C | 비디오 데이터 | 동영상 정보 | 5.0.3.0+ |
| HWPTAG_SHAPE_COMPONENT_UNKNOWN | 0x6D | 알 수 없는 개체 | 미지원 도형 | 5.0+ |

### 필드 컨트롤 레코드 (0x60 ~ 0x7F)
| ID | 이름 | 설명 | 버전 |
|----|------|------|------|
| 0x60 | HWPTAG_FIELD_UNKNOWN | 알 수 없는 필드 | 5.0+ |
| 0x61 | HWPTAG_FIELD_DATE | 날짜 필드 | 5.0+ |
| 0x62 | HWPTAG_FIELD_DOCDATE | 문서 날짜 필드 | 5.0+ |
| 0x63 | HWPTAG_FIELD_PATH | 경로 필드 | 5.0+ |
| 0x64 | HWPTAG_FIELD_BOOKMARK | 책갈피 필드 | 5.0+ |
| 0x65 | HWPTAG_FIELD_MAILMERGE | 메일 머지 필드 | 5.0+ |
| 0x66 | HWPTAG_FIELD_CROSSREF | 상호 참조 필드 | 5.0+ |
| 0x67 | HWPTAG_FIELD_FORMULA | 계산식 필드 | 5.0+ |
| 0x68 | HWPTAG_FIELD_CLICKHERE | 클릭 필드 | 5.0+ |
| 0x69 | HWPTAG_FIELD_SUMMARY | 요약 필드 | 5.0+ |
| 0x6A | HWPTAG_FIELD_USERINFO | 사용자 정보 필드 | 5.0+ |
| 0x6B | HWPTAG_FIELD_HYPERLINK | 하이퍼링크 필드 | 5.0+ |
| 0x6C | HWPTAG_FIELD_REVISION_SIGN | 변경 추적 서명 | 5.0.1.0+ |
| 0x6D | HWPTAG_FIELD_REVISION_DELETE | 변경 추적 삭제 | 5.0.1.0+ |
| 0x6E | HWPTAG_FIELD_REVISION_ATTACH | 변경 추적 첨부 | 5.0.1.0+ |
| 0x6F | HWPTAG_FIELD_REVISION_CLIPPING | 변경 추적 클리핑 | 5.0.1.0+ |
| 0x70 | HWPTAG_FIELD_REVISION_SAWTOOTH | 변경 추적 톱니 | 5.0.1.0+ |
| 0x71 | HWPTAG_FIELD_REVISION_THINKING | 변경 추적 생각 | 5.0.1.0+ |
| 0x72 | HWPTAG_FIELD_REVISION_PRAISE | 변경 추적 칭찬 | 5.0.1.0+ |
| 0x73 | HWPTAG_FIELD_REVISION_LINE | 변경 추적 선 | 5.0.1.0+ |
| 0x74 | HWPTAG_FIELD_REVISION_SIMPLECHANGE | 변경 추적 단순 변경 | 5.0.1.0+ |
| 0x75 | HWPTAG_FIELD_REVISION_HYPERLINK | 변경 추적 하이퍼링크 | 5.0.1.0+ |
| 0x76 | HWPTAG_FIELD_REVISION_LINEATTACH | 변경 추적 선 첨부 | 5.0.1.0+ |
| 0x77 | HWPTAG_FIELD_REVISION_LINELINK | 변경 추적 선 링크 | 5.0.1.0+ |
| 0x78 | HWPTAG_FIELD_REVISION_LINETRANSFER | 변경 추적 선 이동 | 5.0.1.0+ |
| 0x79 | HWPTAG_FIELD_REVISION_RIGHTMOVE | 변경 추적 오른쪽 이동 | 5.0.1.0+ |
| 0x7A | HWPTAG_FIELD_REVISION_LEFTMOVE | 변경 추적 왼쪽 이동 | 5.0.1.0+ |
| 0x7B | HWPTAG_FIELD_REVISION_TRANSFER | 변경 추적 이동 | 5.0.1.0+ |
| 0x7C | HWPTAG_FIELD_REVISION_SIMPLEINSERT | 변경 추적 단순 삽입 | 5.0.1.0+ |
| 0x7D | HWPTAG_FIELD_REVISION_SPLIT | 변경 추적 분할 | 5.0.1.0+ |
| 0x7E | HWPTAG_FIELD_REVISION_CHANGE | 변경 추적 변경 | 5.0.1.0+ |
| 0x7F | HWPTAG_FIELD_MEMO | 메모 필드 | 5.0.1.0+ |

## 레코드 읽기 알고리즘

### 기본 레코드 읽기

```python
def read_records(stream):
    records = []
    
    while not stream.eof():
        # 태그 읽기
        tag = stream.read_dword()
        
        # 태그 분해
        tag_id = (tag >> 22) & 0x3FF
        level = (tag >> 12) & 0x3FF
        size = tag & 0xFFF
        
        # 확장 크기 처리
        if size == 0xFFF:
            size = stream.read_dword()
        
        # 압축 처리 (5.0.1.0+)
        data = None
        if is_compressed_record(tag_id):
            original_size = stream.read_dword()
            compressed_data = stream.read_bytes(size - 4)
            data = decompress_zlib(compressed_data)
        else:
            data = stream.read_bytes(size)
        
        # 레코드 저장
        records.append({
            'tag_id': tag_id,
            'level': level,
            'size': size,
            'data': data,
            'compressed': is_compressed_record(tag_id)
        })
    
    return records
```

### 고급 파싱 알고리즘

```python
def parse_advanced_record(stream, tag_id, version):
    """버전별 고급 레코드 파싱"""
    
    base_data = parse_base_record(stream, tag_id)
    
    # 버전별 확장 필드 처리
    if version >= (5, 0, 1, 0):
        if tag_id == HWPTAG_PARA_HEADER:
            instance_id = stream.read_dword()
            base_data['instance_id'] = instance_id
            
        if tag_id == HWPTAG_TABLE:
            zone_count = stream.read_word()
            zones = []
            for i in range(zone_count):
                zone = {
                    'start_row': stream.read_word(),
                    'start_col': stream.read_word(),
                    'end_row': stream.read_word(),
                    'end_col': stream.read_word(),
                    'border_fill_id': stream.read_word()
                }
                zones.append(zone)
            base_data['zones'] = zones
    
    if version >= (5, 0, 2, 0):
        if tag_id == HWPTAG_CHART_DATA:
            # OOXML 차트 이중 저장 시스템
            ooxml_size = stream.read_dword()
            ooxml_data = stream.read_bytes(ooxml_size)
            base_data['ooxml_chart'] = ooxml_data
    
    if version >= (5, 0, 3, 0):
        if tag_id == HWPTAG_SHAPE_COMPONENT:
            # 세그먼트 타입 인코딩
            segment_count = stream.read_word()
            segments = []
            for i in range(segment_count):
                segment_type = stream.read_byte()
                segment_data = parse_segment_by_type(stream, segment_type)
                segments.append({'type': segment_type, 'data': segment_data})
            base_data['vector_segments'] = segments
    
    return base_data

def parse_segment_by_type(stream, segment_type):
    """세그먼트 타입별 파싱"""
    if segment_type == SEGMENT_MOVETO:
        return {'x': stream.read_int32(), 'y': stream.read_int32()}
    elif segment_type == SEGMENT_LINETO:
        return {'x': stream.read_int32(), 'y': stream.read_int32()}
    elif segment_type == SEGMENT_CURVETO:
        return {
            'x1': stream.read_int32(), 'y1': stream.read_int32(),
            'x2': stream.read_int32(), 'y2': stream.read_int32(),
            'x3': stream.read_int32(), 'y3': stream.read_int32()
        }
    # 추가 세그먼트 타입들...
    return {}
```

## 계층 구조

레벨 값은 레코드의 계층 구조를 나타냅니다:
- 레벨 0: 최상위 레코드 (문단, 페이지 정의)
- 레벨 1: 하위 레코드 (텍스트, 글자 모양)
- 레벨 2: 더 깊은 하위 레코드 (컨트롤 데이터)
- 레벨 3+: 중첩 컨트롤 (표 안의 표, 글상자 안의 그림)

### 표준 계층 구조 예시:
```
[레벨 0] HWPTAG_PARA_HEADER (문단 헤더)
  [레벨 1] HWPTAG_PARA_TEXT (문단 텍스트)
  [레벨 1] HWPTAG_PARA_CHAR_SHAPE (글자 모양)
  [레벨 1] HWPTAG_PARA_LINE_SEG (줄 나눔)
  [레벨 1] HWPTAG_CTRL_HEADER (컨트롤 헤더)
    [레벨 2] HWPTAG_TABLE (표 데이터)
      [레벨 3] HWPTAG_LIST_HEADER (셀 리스트)
        [레벨 4] HWPTAG_PARA_HEADER (셀 내 문단)
          [레벨 5] HWPTAG_PARA_TEXT (셀 텍스트)
```

### 중첩 제한 및 규칙
- **최대 레벨**: 1023 (10비트)
- **실용적 제한**: 레벨 10까지 권장
- **순환 참조 방지**: 같은 레벨에서 상위 레벨 참조 금지
- **스킵 규칙**: 알 수 없는 레코드 계층 전체 스킵 가능

### 필드 중첩 처리

필드 컨트롤 내부의 중첩 구조:
```
[레벨 1] HWPTAG_FIELD_FORMULA (계산식 필드)
  [레벨 2] 수식 데이터
  [레벨 2] 결과 캐시
  [레벨 2] 의존성 정보
    [레벨 3] 참조 셀 정보
    [레벨 3] 업데이트 타임스탬프
```

## 레코드 스킵 및 호환성

### 기본 스킵 알고리즘

알 수 없는 레코드를 만났을 때:
1. 레코드 헤더에서 크기 정보 추출
2. 확장 크기인 경우 추가 크기 정보 읽기
3. 해당 크기만큼 스트림에서 건너뛰기
4. 다음 레코드로 계속 진행
5. 오류 발생시키지 않음 (상위 버전 호환성)

### 고급 스킵 전략

```python
def skip_unknown_record(stream, tag_id, level, size):
    """알 수 없는 레코드 스킵"""
    
    # 계층 구조 고려한 스킵
    if level > 0:
        # 하위 레코드들도 함께 스킵
        current_level = level
        bytes_skipped = 0
        
        while bytes_skipped < size:
            next_tag = stream.peek_dword()
            next_level = (next_tag >> 12) & 0x3FF
            
            if next_level <= level:
                break  # 같거나 상위 레벨 만나면 중단
            
            # 하위 레코드 스킵
            sub_record_size = skip_single_record(stream)
            bytes_skipped += sub_record_size
    else:
        # 단일 레코드 스킵
        stream.skip(size)

def validate_record_integrity(tag_id, level, size, version):
    """레코드 무결성 검증"""
    
    # 버전별 유효성 검사
    if version < (5, 0, 1, 0) and tag_id >= 0x59:
        return False  # 상위 버전 레코드
    
    # 크기 합리성 검사
    if size > MAX_REASONABLE_SIZE:
        return False
    
    # 레벨 깊이 검사
    if level > MAX_NESTING_LEVEL:
        return False
    
    return True
```

### 버전별 호환성 매트릭스

| 파서 버전 | 지원 레코드 범위 | 특별 기능 |
|-----------|------------------|----------|
| 5.0.0.0 | 0x00-0x58 | 기본 레코드만 |
| 5.0.1.0 | 0x00-0x5A | 인스턴스 ID, 압축 |
| 5.0.2.0 | 0x00-0x5C | 히스토리, 확장 번호 |
| 5.0.3.0 | 0x00-0x7F | 세그먼트, 고급 효과 |

이를 통해 상위 버전 파일도 부분적으로 읽을 수 있습니다.

## 고급 레코드 처리

### 인스턴스 ID 시스템 (5.0.1.0+)

문단 레코드는 고유한 인스턴스 ID를 가질 수 있습니다:

```c
struct ParaHeaderWithInstance {
    DWORD standardFields;   // 표준 문단 헤더 필드들
    DWORD instanceId;       // 고유 인스턴스 ID (32비트)
}
```

### 문서 히스토리 추적 (5.0.2.0+)

```c
struct DocumentHistory {
    DWORD versionNumber;    // 문서 버전 번호
    DWORD changeCount;      // 총 변경 횟수
    DWORD lastModified;     // 마지막 수정 시간 (Unix timestamp)
    BYTE trackingFlags;     // 추적 플래그
}
```

### 세그먼트 타입 인코딩 (5.0.3.0+)

하이브리드 벡터 경로용 세그먼트 인코딩:

```c
enum SegmentType {
    SEGMENT_MOVETO = 0x00,      // 이동
    SEGMENT_LINETO = 0x01,      // 직선
    SEGMENT_CURVETO = 0x02,     // 곡선
    SEGMENT_CLOSEPATH = 0x03,   // 경로 닫기
    SEGMENT_ELLIPSE = 0x04,     // 타원
    SEGMENT_ARC = 0x05,         // 호
    SEGMENT_SPLINE = 0x06       // 스플라인
};
```

### 필드 명령 처리 시스템

필드 내 특수 마커:
- `^n`: 줄바꿈 명령
- `^N`: 페이지 나눔 명령
- `^t`: 탭 명령
- `^s`: 공백 명령
- `^d`: 날짜 삽입 명령
- `^c`: 계산 결과 삽입

### 고급 색상 효과 파이프라인 (5.0.3.0+)

```c
enum ColorEffect {
    EFFECT_NONE = 0,
    EFFECT_GRAYSCALE = 1,
    EFFECT_BRIGHTNESS = 2,
    EFFECT_CONTRAST = 3,
    EFFECT_ALPHA = 4,
    EFFECT_WATERCOLOR = 5,
    // ... 총 27가지 효과
};
```

### 한국어 번호 매기기 확장 (5.0.2.0+)

레벨 10까지 확장된 번호 매기기:

```c
struct ExtendedNumbering {
    WORD starts[10];        // 레벨 1-10 시작 번호
    DWORD properties[10];   // 레벨별 속성
    WORD charShapes[10];    // 레벨별 글자 모양 ID
    BYTE koreanStyles[10];  // 한국어 스타일 (가/나/다/라/마/바/사/아/자/차)
}
```

## 주의사항

1. **정렬**: 레코드는 4바이트 정렬되지 않음
2. **순서**: 레코드 순서가 중요함 (특히 ID 매핑이 먼저)
3. **중복**: 같은 태그 ID가 여러 번 나올 수 있음
4. **크기**: 크기 0인 레코드도 유효함
5. **버전 호환성**: 상위 버전 필드는 크기로 감지
6. **바이트 순서**: 모든 다중 바이트 값은 리틀 엔디안
7. **압축 레코드**: 개별 레코드별 압축 지원 (5.0.1.0+)
8. **인스턴스 추적**: 문단별 고유 ID로 변경 추적 (5.0.1.0+)
9. **확장 필드**: 새 버전에서 추가된 필드는 하위 호환성 유지
10. **보호 수준**: 문서별 4단계 보호 수준 지원 (5.0.3.0+)