# 저장 방식의 개념

## 복합 파일 구조

한글 문서는 Microsoft의 복합 파일(Compound File) 또는 구조화된 스토리지(Structured Storage) 형식을 사용합니다. 이는 하나의 파일 안에 파일 시스템과 유사한 구조를 만드는 방식입니다.

## 기본 개념

### 1. 스토리지 (Storage)
- 파일 시스템의 **디렉토리**에 해당
- 다른 스토리지나 스트림을 포함할 수 있음
- 계층적 구조 형성 가능

### 2. 스트림 (Stream)
- 파일 시스템의 **파일**에 해당
- 실제 데이터를 포함
- 순차적 바이트 배열로 구성

### 3. 루트 스토리지 (Root Storage)
- 최상위 스토리지
- 모든 다른 스토리지와 스트림의 부모

## 장점

1. **단일 파일**: 모든 관련 데이터를 하나의 파일에 저장
2. **구조화**: 논리적으로 관련된 데이터를 그룹화
3. **확장성**: 새로운 스트림을 추가하여 기능 확장 가능
4. **호환성**: 표준 OLE 도구로 내용 확인 가능

## 파일 구조 예시

```
한글파일.hwp (루트 스토리지)
│
├─ FileHeader (스트림) - 파일 식별 정보
├─ DocInfo (스트림) - 문서 전체 정보
├─ BodyText (스토리지) - 본문 내용
│  ├─ Section0 (스트림) - 첫 번째 섹션
│  ├─ Section1 (스트림) - 두 번째 섹션
│  └─ ...
├─ BinData (스토리지) - 이미지, OLE 객체 등
│  ├─ BIN0001.jpg (스트림)
│  ├─ BIN0002.png (스트림)
│  └─ ...
└─ Scripts (스토리지) - 매크로 스크립트
   ├─ JScript (스트림)
   └─ VBScript (스트림)
```

## 접근 방법

### 1. Windows API 사용
```c
// 복합 파일 열기
HRESULT hr = StgOpenStorage(
    filename,                           // 파일 경로
    NULL,                              // 우선순위 없음
    STGM_READ | STGM_SHARE_DENY_WRITE, // 읽기 전용, 쓰기 차단
    NULL,                              // 예약
    0,                                 // 예약
    &pStorage                          // 스토리지 인터페이스
);

// 스토리지 열거
IEnumSTATSTG *pEnum;
pStorage->EnumElements(0, NULL, 0, &pEnum);

STATSTG stat;
while (pEnum->Next(1, &stat, NULL) == S_OK) {
    if (stat.type == STGTY_STREAM) {
        // 스트림 처리
        IStream *pStream;
        pStorage->OpenStream(stat.pwcsName, NULL,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
        
        // 데이터 읽기
        BYTE buffer[1024];
        ULONG bytesRead;
        pStream->Read(buffer, 1024, &bytesRead);
        
        pStream->Release();
    }
    CoTaskMemFree(stat.pwcsName);
}

pEnum->Release();
pStorage->Release();
```

### 2. CompoundFile API 직접 사용 (5.0.3.0+)

```c
// 고급 스토리지 열기
IStorage* openHwpStorage(const wchar_t* filename) {
    IStorage* pStorage = NULL;
    
    // 복합 파일 서명 검증
    if (!validateCompoundFileSignature(filename)) {
        return NULL;
    }
    
    // 트랜잭션 모드로 열기
    HRESULT hr = StgOpenStorageEx(
        filename,
        STGM_READ | STGM_SHARE_DENY_WRITE | STGM_TRANSACTED,
        STGFMT_STORAGE,  // 표준 복합 파일 형식
        0,
        NULL,
        NULL,
        IID_IStorage,
        (void**)&pStorage
    );
    
    return SUCCEEDED(hr) ? pStorage : NULL;
}

// 암호화된 스트림 열기 (5.0.3.0+)
IStream* openEncryptedStream(IStorage* pStorage, const wchar_t* streamName, 
                            const BYTE* password, DWORD passwordLen) {
    IStream* pStream = NULL;
    
    // 일반 스트림으로 열기 시도
    HRESULT hr = pStorage->OpenStream(streamName, NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    
    if (SUCCEEDED(hr)) {
        // 암호화 여부 확인
        if (isStreamEncrypted(pStream)) {
            // 암호화 스트림래퍼 사용
            IStream* pDecryptedStream = createDecryptedStream(pStream, password, passwordLen);
            pStream->Release();
            return pDecryptedStream;
        }
    }
    
    return pStream;
}
```

### 3. 라이브러리 사용

#### Python
```python
import olefile

# 복합 파일 열기
ole = olefile.OleFileIO('document.hwp')

# 스트림 목록 확인
streams = ole.listdir()
print('사용 가능한 스트림:', streams)

# 스트림 읽기
with ole.open_stream('DocInfo') as stream:
    data = stream.read()
    print(f'DocInfo 크기: {len(data)} bytes')

ole.close()
```

#### Java (Apache POI)
```java
import org.apache.poi.poifs.filesystem.*;

// 복합 파일 열기
POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream("document.hwp"));

// 디렉토리 엔트리 열거
DirectoryEntry root = fs.getRoot();
for (Entry entry : root) {
    System.out.println("엔트리: " + entry.getName());
    
    if (entry instanceof DocumentEntry) {
        DocumentEntry doc = (DocumentEntry) entry;
        DocumentInputStream dis = new DocumentInputStream(doc);
        
        byte[] data = new byte[doc.getSize()];
        dis.read(data);
        dis.close();
        
        System.out.println("데이터 크기: " + data.length);
    }
}

fs.close();
```

#### C# (OpenMCDF)
```csharp
using OpenMcdf;

// 복합 파일 열기
CompoundFile cf = new CompoundFile("document.hwp");

// 스트림 열거
void EnumerateStorage(CFStorage storage, string path = "") {
    foreach (CFItem item in storage) {
        string fullPath = path + "\\" + item.Name;
        
        if (item.IsStream) {
            CFStream stream = item as CFStream;
            byte[] data = stream.GetData();
            Console.WriteLine($"스트림: {fullPath}, 크기: {data.Length}");
        } else if (item.IsStorage) {
            CFStorage subStorage = item as CFStorage;
            Console.WriteLine($"스토리지: {fullPath}");
            EnumerateStorage(subStorage, fullPath);
        }
    }
}

EnumerateStorage(cf.RootStorage);
cf.Close();
```

### 4. 웹 환경에서의 접근

#### JavaScript (Node.js)
```javascript
const CFB = require('cfb');
const fs = require('fs');

// HWP 파일 읽기
const hwpData = fs.readFileSync('document.hwp');
const cfb = CFB.read(hwpData, {type: 'buffer'});

// 스트림 목록 확인
cfb.FileIndex.forEach((file, index) => {
    if (file.type === 2) {  // 스트림
        console.log(`스트림: ${file.name}, 크기: ${file.size}`);
        
        // 데이터 읽기
        const data = CFB.find(cfb, file.name);
        if (data) {
            console.log(`데이터 처음 16바이트:`, data.content.slice(0, 16));
        }
    }
});
```

### 5. 라이브러리 비교

| 라이브러리 | 언어 | 특징 | 성능 | 암호화 지원 |
|---------|------|------|------|------------|
| Windows API | C/C++ | 네이티브, 전체 기능 | 매우 빠름 | 지원 |
| Apache POI | Java | 크로스 플랫폼 | 빠름 | 제한적 |
| OpenMCDF | C# | .NET 전용 | 빠름 | 지원 |
| olefile | Python | 순수 Python | 보통 | 제한적 |
| CFB | JavaScript | 웹 환경 | 보통 | 없음 |

## 메타데이터

각 스토리지와 스트림은 다음 메타데이터를 가집니다:

### 기본 메타데이터
- **이름**: UTF-16 인코딩 이름 (31자 제한)
- **생성 시간**: FILETIME 구조체 (64비트)
- **수정 시간**: FILETIME 구조체 (64비트)
- **크기**: 스트림의 경우 바이트 단위 크기
- **속성 플래그**: 읽기 전용, 숨김 등

### 확장 메타데이터 (5.0.1.0+)

```c
struct ExtendedMetadata {
    DWORD version;              // 스트림 버전
    DWORD checksum;             // CRC32 체크섬
    DWORD compressionMethod;    // 압축 방식
    DWORD originalSize;         // 원본 크기
    DWORD compressedSize;       // 압축된 크기
    FILETIME lastAccessTime;    // 마지막 접근 시간
    GUID streamId;              // 스트림 고유 ID
    DWORD encryptionMethod;     // 암호화 방식
    BYTE encryptionIV[16];      // 암호화 초기화 벡터
};
```

### 메타데이터 읽기

```c
void readStreamMetadata(IStorage* pStorage, const wchar_t* streamName) {
    STATSTG stat;
    IStream* pStream;
    
    // 스트림 열기
    HRESULT hr = pStorage->OpenStream(streamName, NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    
    if (SUCCEEDED(hr)) {
        // 메타데이터 얻기
        hr = pStream->Stat(&stat, STATFLAG_DEFAULT);
        
        if (SUCCEEDED(hr)) {
            printf("스트림 이름: %ls\n", stat.pwcsName);
            printf("크기: %llu bytes\n", stat.cbSize.QuadPart);
            printf("수정 시간: %08x-%08x\n", 
                   stat.mtime.dwHighDateTime, stat.mtime.dwLowDateTime);
            
            CoTaskMemFree(stat.pwcsName);
        }
        
        pStream->Release();
    }
}
```

## 고급 기능 및 확장 (5.0.1.0+)

### 압축 스트림 지원

```c
// 압축된 스트림 식별
struct CompressedStreamHeader {
    DWORD signature;            // 'ZLIB' (0x42494C5A)
    DWORD originalSize;         // 원본 크기
    DWORD compressedSize;       // 압축된 크기
    DWORD crc32;               // 원본 데이터 CRC32
};

// 압축 해제
int decompressStream(IStream* pCompressedStream, BYTE** ppDecompressed) {
    CompressedStreamHeader header;
    ULONG bytesRead;
    
    // 헤더 읽기
    pCompressedStream->Read(&header, sizeof(header), &bytesRead);
    
    if (header.signature != 0x42494C5A) {
        return -1;  // 압축되지 않은 스트림
    }
    
    // 압축된 데이터 읽기
    BYTE* compressedData = malloc(header.compressedSize);
    pCompressedStream->Read(compressedData, header.compressedSize, &bytesRead);
    
    // zlib 압축 해제
    *ppDecompressed = malloc(header.originalSize);
    int result = uncompress(*ppDecompressed, &header.originalSize, 
                           compressedData, header.compressedSize);
    
    free(compressedData);
    return result;
}
```

### 암호화 스트림 지원 (5.0.3.0+)

```c
// 암호화된 스트림 구조
struct EncryptedStreamHeader {
    DWORD signature;            // 'CRYP' (0x50595243)
    DWORD version;              // 암호화 버전
    DWORD keyDerivationMethod;  // 키 도출 방법
    DWORD encryptionMethod;     // 암호화 방법 (AES-256-CBC)
    BYTE salt[16];             // 솔트
    BYTE iv[16];               // 초기화 벡터
    DWORD encryptedSize;       // 암호화된 데이터 크기
};

// 암호화 버전별 지원
enum EncryptionVersion {
    ENCRYPTION_NONE = 0,        // 암호화 없음
    ENCRYPTION_HWP25 = 1,       // HWP 2.5 호환
    ENCRYPTION_HWP30_ENHANCED = 2,  // HWP 3.0 강화
    ENCRYPTION_HWP30_OLD = 3,   // HWP 3.0 구형
    ENCRYPTION_HWP70_PLUS = 4   // HWP 7.0+ (AES-256)
};
```

### 트랜잭션 지원

```c
// 트랜잭션 모드로 복합 파일 열기
IStorage* openTransactedStorage(const wchar_t* filename) {
    IStorage* pStorage = NULL;
    
    HRESULT hr = StgOpenStorage(filename, NULL,
        STGM_READWRITE | STGM_TRANSACTED,  // 트랜잭션 모드
        NULL, 0, &pStorage);
    
    return SUCCEEDED(hr) ? pStorage : NULL;
}

// 변경사항 커밋
void commitChanges(IStorage* pStorage) {
    pStorage->Commit(STGC_DEFAULT);
}

// 변경사항 롤백
void rollbackChanges(IStorage* pStorage) {
    pStorage->Revert();
}
```

## 주의사항 및 제약

### 기본 제약
1. **이름 규칙**: 스토리지/스트림 이름은 대소문자를 구분하지 않음
2. **경로 구분자**: 백슬래시(\\) 사용
3. **최대 이름 길이**: 31자 (NULL 제외)
4. **인코딩**: 이름은 UTF-16으로 저장
5. **제약 사항**: 특수 문자 사용 금지 (\, /, :, *, ?, ", <, >, |)
6. **대소문자**: 대소문자 구분 안 함 (Case-insensitive)
7. **예약 이름**: COM1-COM9, LPT1-LPT9, CON, PRN, AUX, NUL 사용 불가

### 성능 고려사항

1. **섹터 크기**: 512바이트 vs 4096바이트 선택
   - 512B: 작은 파일에 적합, 호환성 우수
   - 4096B: 큰 파일에 적합, 성능 우수

2. **미니 스트림**: 4096바이트 미만 스트림은 미니 FAT 사용

3. **메모리 매핑**: 큰 파일은 메모리 매핑 사용 금지

4. **동시 접근**: 동시 읽기/쓰기 시 록 기능 활용

### 보안 고려사항 (5.0.3.0+)

1. **암호화 스트림**: AES-256-CBC 암호화 지원
2. **디지털 서명**: RSA-2048 디지털 서명 지원
3. **접근 과역**: 미인가된 스트림 접근 차단
4. **무결성 검사**: CRC32/SHA-256 체크섬 지원

### 호환성 및 버전 관리

1. **상위 버전**: 새 스트림 추가 시 하위 버전에서 무시
2. **하위 버전**: 알 수 없는 스트림 발견 시 경고 출력 후 계속
3. **중요 스트림**: FileHeader, DocInfo, BodyText는 필수
4. **선택 스트림**: BinData, Scripts 등은 선택적